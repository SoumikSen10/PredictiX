# -*- coding: utf-8 -*-
"""LungCancerDetection15.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19FTpH6ZitsoNsKhUuD9nnGc_JtdsFko8
"""

# Mount Google Drive
from google.colab import drive
drive.mount('/content/drive')

train_dir = "/content/drive/MyDrive/dataset/train"
valid_dir = "/content/drive/MyDrive/dataset/valid"
test_dir = "/content/drive/MyDrive/dataset/test"

import pandas as pd
from PIL import Image
import os

MAIN_DIR = "/content/drive/MyDrive/dataset"

data = []
for split in ["train", "valid", "test"]:
    for dirname, _, filenames in os.walk(f'{MAIN_DIR}/{split}/'):
        if len(filenames) > 0:
            target = dirname.split("/")[-1]
            if "_" in target:
                target = target.split("_")[0]
            data.append({"files": filenames, "target": target, "split": split, "folder": dirname.split("/")[-1] })
df = pd.DataFrame(data)
df = df.explode("files")
df["path"] = df["split"] + "/" + df["folder"] + "/" + df["files"]
for index, row in df.iterrows():
    with Image.open(f"{MAIN_DIR}/{row.path}") as image:
        height, width = image.size
        df.loc[index, "height"] = height
        df.loc[index, "width"] = width
df = df.reset_index(drop=True)
df

import matplotlib.image as mpimg
import matplotlib.pyplot as plt

# Read Images
sample = df.sample(4)
for i in range(4):
    plt.subplot(2, 2, i+1)
    img = mpimg.imread(f'{MAIN_DIR}/{sample.iloc[i].path}')
    plt.imshow(img)
plt.tight_layout()
plt.show()

import seaborn as sns

sns.jointplot(df, x="width", y="height")
plt.show()

sns.countplot(df[(df["split"] == "train") | (df["split"] == "valid")], x="target")
plt.tight_layout()
plt.show()

from keras.applications import InceptionResNetV2
from keras.metrics import CategoricalAccuracy, Precision, Recall, AUC
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from keras import Input, layers, Model, metrics, optimizers, losses, callbacks
import tensorflow as tf
from numpy.random import seed
seed(42)
tf.random.set_seed(42)

input_model = Input(shape= (256, 256, 3))
inception_model = InceptionResNetV2(
    include_top=False,
    weights="imagenet",
    input_tensor=input_model)
inception_model.trainable=False

x = layers.GlobalAveragePooling2D()(inception_model.output)
x = layers.Dropout(0.25)(x)
x = layers.Dense(4, activation="softmax", trainable=True)(x)
model = Model(inception_model.input, x)
model.compile(optimizer=optimizers.Adam(), loss=losses.BinaryCrossentropy(label_smoothing=0.1),
            metrics=[CategoricalAccuracy(), Precision(), Recall(), AUC()])
model.summary()

generator = ImageDataGenerator  (rescale = 1./255)

train_generator = generator.flow_from_dataframe(df[df.split == "train"], directory=MAIN_DIR,
    x_col='path', y_col='target', target_size = (256, 256), batch_size=32,
    class_mode='categorical')

val_generator = generator.flow_from_dataframe(df[df.split == "valid"], directory=MAIN_DIR,
    x_col='path', y_col='target', target_size = (256, 256), batch_size=32,
    class_mode='categorical')
test_generator = generator.flow_from_dataframe(df[df.split == "test"], directory=MAIN_DIR,
    x_col='path', y_col='target', target_size = (256, 256), batch_size=32,
    class_mode='categorical')

learning_rate = 0.1
epochs = 20
decay_rate = 0.2
def scheduler(epoch):
    new_lr =  learning_rate * np.exp(-decay_rate * epoch)
    if new_lr > 0.001:
        return new_lr
    return 0.001
callbacks_list = [
    callbacks.EarlyStopping(monitor = "val_loss", patience = 5),
    callbacks.ModelCheckpoint(filepath="LCD.h5", monitor="val_loss", verbose=1, save_best_only=True),
    callbacks.LearningRateScheduler(scheduler)
]

import numpy as np

history = model.fit(train_generator,
                    validation_data=val_generator,
                    epochs=epochs,
                    callbacks = callbacks_list)

metrics = model.evaluate(test_generator)
pd.DataFrame([metrics], columns=["loss", "Accuracy", "Precision", "Recall", "AUC"])

import pickle
from tensorflow.keras.models import load_model

# Load the saved model
model = load_model('LCD.h5')

# Save the model using pickle
with open('LCD_model.pkl', 'wb') as f:
    pickle.dump(model, f)

print("Model saved as pickle file: LCD_model.pkl")

from tensorflow.keras.preprocessing import image
import numpy as np
import matplotlib.pyplot as plt

# Class labels
class_labels = ['squamous cell carcinoma', 'large cell carcinoma', 'normal', 'adenocarcinoma']

# Function to load and preprocess an image for prediction
def load_and_preprocess_image(img_path, target_size):
    img = image.load_img(img_path, target_size=target_size)
    img_array = image.img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)
    img_array /= 255.0  # Rescale the image like the training images
    return img_array

# Function to make a prediction
def predict_cell_class(img_path):
    # Preprocess the image
    img = load_and_preprocess_image(img_path, (256, 256))  # Adjusted image size

    # Make a prediction
    predictions = model.predict(img)
    predicted_class = np.argmax(predictions[0])

    # Get the class label
    predicted_label = class_labels[predicted_class]

    # Determine if the cell is cancerous or non-cancerous
    if predicted_label == 'normal':
        cancerous_label = 'non-cancerous'
    else:
        cancerous_label = 'cancerous'

    # Print the predicted class and cancerous label
    print(f"The image belongs to class: {cancerous_label}")

    # Display the image with the predicted class and cancerous label
    plt.imshow(image.load_img(img_path, target_size=(256, 256)))  # Adjusted image size
    plt.title(f"Predicted: {cancerous_label}")
    plt.axis('off')
    plt.show()

# Path to the image you want to predict
img_path = '/content/drive/MyDrive/dataset/test/normal/12 - Copy (2) - Copy.png'

# Predict the class of the provided cell
predict_cell_class(img_path)

from tensorflow.keras.preprocessing import image
import numpy as np
import matplotlib.pyplot as plt

# Class labels
class_labels = ['squamous cell carcinoma', 'large cell carcinoma', 'normal', 'adenocarcinoma']

# Function to load and preprocess an image for prediction
def load_and_preprocess_image(img_path, target_size):
    img = image.load_img(img_path, target_size=target_size)
    img_array = image.img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)
    img_array /= 255.0  # Rescale the image like the training images
    return img_array

# Function to make a prediction
def predict_cell_class(img_path):
    # Preprocess the image
    img = load_and_preprocess_image(img_path, (256, 256))  # Adjusted image size

    # Make a prediction
    predictions = model.predict(img)
    predicted_class = np.argmax(predictions[0])

    # Get the class label
    predicted_label = class_labels[predicted_class]

    # Determine if the cell is cancerous or non-cancerous
    if predicted_label == 'normal':
        cancerous_label = 'non-cancerous'
    else:
        cancerous_label = 'cancerous'

    # Print the predicted class and cancerous label
    print(f"The image belongs to class: {cancerous_label}")

    # Display the image with the predicted class and cancerous label
    plt.imshow(image.load_img(img_path, target_size=(256, 256)))  # Adjusted image size
    plt.title(f"Predicted: {cancerous_label}")
    plt.axis('off')
    plt.show()

# Path to the image you want to predict
img_path = '/content/drive/MyDrive/dataset/test/squamous.cell.carcinoma_left.hilum_T1_N2_M0_IIIa/000114 (3).png'

# Predict the class of the provided cell
predict_cell_class(img_path)